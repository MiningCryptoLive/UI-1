/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosError, AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import * as moment from 'moment';

export interface IPoolApiClient {
    poolsApi(): Promise<PoolListInfo[]>;
    poolBlocksApi(id: string | null, page: number | undefined, pageSize: number | undefined): Promise<PagedResultResponseOfBlockOf>;
    poolPaymentsApi(id: string | null, page: number | undefined, pageSize: number | undefined): Promise<PagedResultResponseOfPaymentOf>;
    minerPaymentsApi(id: string | null, account: string | null, page: number | undefined, pageSize: number | undefined): Promise<PagedResultResponseOfPaymentOf>;
    minerEarningsApi(id: string | null, account: string | null, page: number | undefined, pageSize: number | undefined): Promise<PagedResultResponseOfAmountByDateOf>;
    minerBalanceChangesApi(id: string | null, account: string | null, page: number | undefined, pageSize: number | undefined): Promise<PagedResultResponseOfBalanceChangeOf>;
    minerSettings(id: string | null, account: string | null, request: UpdateMinerSettingsRequest): Promise<ResultResponseOfMinerSettings>;
    poolMinerStatsApi(id: string | null, address: string | null, perfMode: SampleRange | undefined): Promise<ResultResponseOfMinerStats>;
}

export class PoolApiClient implements IPoolApiClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {

        this.instance = instance ? instance : axios.create();

        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";

    }

    poolsApi(  cancelToken?: CancelToken | undefined): Promise<PoolListInfo[]> {
        let url_ = this.baseUrl + "/api/pools";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPoolsApi(_response);
        });
    }

    protected processPoolsApi(response: AxiosResponse): Promise<PoolListInfo[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PoolListInfo.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return Promise.resolve<PoolListInfo[]>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PoolListInfo[]>(<any>null);
    }

    poolBlocksApi(id: string | null, page: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultResponseOfBlockOf> {
        let url_ = this.baseUrl + "/api/pools/{id}/blocks?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPoolBlocksApi(_response);
        });
    }

    protected processPoolBlocksApi(response: AxiosResponse): Promise<PagedResultResponseOfBlockOf> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultResponseOfBlockOf.fromJS(resultData200);
            return Promise.resolve<PagedResultResponseOfBlockOf>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultResponseOfBlockOf>(<any>null);
    }

    poolPaymentsApi(id: string | null, page: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultResponseOfPaymentOf> {
        let url_ = this.baseUrl + "/api/pools/{id}/payments?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPoolPaymentsApi(_response);
        });
    }

    protected processPoolPaymentsApi(response: AxiosResponse): Promise<PagedResultResponseOfPaymentOf> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultResponseOfPaymentOf.fromJS(resultData200);
            return Promise.resolve<PagedResultResponseOfPaymentOf>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultResponseOfPaymentOf>(<any>null);
    }

    minerPaymentsApi(id: string | null, account: string | null, page: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultResponseOfPaymentOf> {
        let url_ = this.baseUrl + "/api/pools/{id}/account/{account}/payments?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMinerPaymentsApi(_response);
        });
    }

    protected processMinerPaymentsApi(response: AxiosResponse): Promise<PagedResultResponseOfPaymentOf> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultResponseOfPaymentOf.fromJS(resultData200);
            return Promise.resolve<PagedResultResponseOfPaymentOf>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultResponseOfPaymentOf>(<any>null);
    }

    minerEarningsApi(id: string | null, account: string | null, page: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultResponseOfAmountByDateOf> {
        let url_ = this.baseUrl + "/api/pools/{id}/account/{account}/earnings/daily?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMinerEarningsApi(_response);
        });
    }

    protected processMinerEarningsApi(response: AxiosResponse): Promise<PagedResultResponseOfAmountByDateOf> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultResponseOfAmountByDateOf.fromJS(resultData200);
            return Promise.resolve<PagedResultResponseOfAmountByDateOf>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultResponseOfAmountByDateOf>(<any>null);
    }

    minerBalanceChangesApi(id: string | null, account: string | null, page: number | undefined, pageSize: number | undefined , cancelToken?: CancelToken | undefined): Promise<PagedResultResponseOfBalanceChangeOf> {
        let url_ = this.baseUrl + "/api/pools/{id}/account/{account}/balancechanges?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "pageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMinerBalanceChangesApi(_response);
        });
    }

    protected processMinerBalanceChangesApi(response: AxiosResponse): Promise<PagedResultResponseOfBalanceChangeOf> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultResponseOfBalanceChangeOf.fromJS(resultData200);
            return Promise.resolve<PagedResultResponseOfBalanceChangeOf>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultResponseOfBalanceChangeOf>(<any>null);
    }

    minerSettings(id: string | null, account: string | null, request: UpdateMinerSettingsRequest , cancelToken?: CancelToken | undefined): Promise<ResultResponseOfMinerSettings> {
        let url_ = this.baseUrl + "/api/pools/{id}/account/{account}/settings";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (account === undefined || account === null)
            throw new Error("The parameter 'account' must be defined.");
        url_ = url_.replace("{account}", encodeURIComponent("" + account));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(request);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processMinerSettings(_response);
        });
    }

    protected processMinerSettings(response: AxiosResponse): Promise<ResultResponseOfMinerSettings> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultResponseOfMinerSettings.fromJS(resultData200);
            return Promise.resolve<ResultResponseOfMinerSettings>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultResponseOfMinerSettings>(<any>null);
    }

    poolMinerStatsApi(id: string | null, address: string | null, perfMode: SampleRange | undefined , cancelToken?: CancelToken | undefined): Promise<ResultResponseOfMinerStats> {
        let url_ = this.baseUrl + "/api/pools/{id}/account/{address}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (address === undefined || address === null)
            throw new Error("The parameter 'address' must be defined.");
        url_ = url_.replace("{address}", encodeURIComponent("" + address));
        if (perfMode === null)
            throw new Error("The parameter 'perfMode' cannot be null.");
        else if (perfMode !== undefined)
            url_ += "perfMode=" + encodeURIComponent("" + perfMode) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            },
            cancelToken
        };

        return this.instance.request(options_).catch((_error: any) => {
            if (isAxiosError(_error) && _error.response) {
                return _error.response;
            } else {
                throw _error;
            }
        }).then((_response: AxiosResponse) => {
            return this.processPoolMinerStatsApi(_response);
        });
    }

    protected processPoolMinerStatsApi(response: AxiosResponse): Promise<ResultResponseOfMinerStats> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ResultResponseOfMinerStats.fromJS(resultData200);
            return Promise.resolve<ResultResponseOfMinerStats>(result200);

        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ResultResponseOfMinerStats>(<any>null);
    }
}

export class PoolListInfo implements IPoolListInfo {
    coin!: string | undefined;
    id!: string | undefined;
    algorithm!: string | undefined;
    name!: string | undefined;
    hashrate!: number;
    miners!: number;
    fee!: number;
    feeType!: string | undefined;
    blockHeight!: number;

    constructor(data?: IPoolListInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coin = _data["coin"];
            this.id = _data["id"];
            this.algorithm = _data["algorithm"];
            this.name = _data["name"];
            this.hashrate = _data["hashrate"];
            this.miners = _data["miners"];
            this.fee = _data["fee"];
            this.feeType = _data["feeType"];
            this.blockHeight = _data["blockHeight"];
        }
    }

    static fromJS(data: any): PoolListInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PoolListInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coin"] = this.coin;
        data["id"] = this.id;
        data["algorithm"] = this.algorithm;
        data["name"] = this.name;
        data["hashrate"] = this.hashrate;
        data["miners"] = this.miners;
        data["fee"] = this.fee;
        data["feeType"] = this.feeType;
        data["blockHeight"] = this.blockHeight;
        return data;
    }
}

export interface IPoolListInfo {
    coin: string | undefined;
    id: string | undefined;
    algorithm: string | undefined;
    name: string | undefined;
    hashrate: number;
    miners: number;
    fee: number;
    feeType: string | undefined;
    blockHeight: number;
}

export class ResponseBase implements IResponseBase {
    success!: boolean;
    responseMessageType!: ResponseMessageType;
    responseMessageId!: string | undefined;
    responseMessageArgs!: any[] | undefined;

    constructor(data?: IResponseBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            this.responseMessageType = _data["responseMessageType"];
            this.responseMessageId = _data["responseMessageId"];
            if (Array.isArray(_data["responseMessageArgs"])) {
                this.responseMessageArgs = [] as any;
                for (let item of _data["responseMessageArgs"])
                    this.responseMessageArgs!.push(item);
            }
        }
    }

    static fromJS(data: any): ResponseBase {
        data = typeof data === 'object' ? data : {};
        let result = new ResponseBase();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        data["responseMessageType"] = this.responseMessageType;
        data["responseMessageId"] = this.responseMessageId;
        if (Array.isArray(this.responseMessageArgs)) {
            data["responseMessageArgs"] = [];
            for (let item of this.responseMessageArgs)
                data["responseMessageArgs"].push(item);
        }
        return data;
    }
}

export interface IResponseBase {
    success: boolean;
    responseMessageType: ResponseMessageType;
    responseMessageId: string | undefined;
    responseMessageArgs: any[] | undefined;
}

export class ResultResponseOfBlockOf extends ResponseBase implements IResultResponseOfBlockOf {
    result!: Block[] | undefined;

    constructor(data?: IResultResponseOfBlockOf) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Block.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultResponseOfBlockOf {
        data = typeof data === 'object' ? data : {};
        let result = new ResultResponseOfBlockOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultResponseOfBlockOf extends IResponseBase {
    result: Block[] | undefined;
}

export class PagedResultResponseOfBlockOf extends ResultResponseOfBlockOf implements IPagedResultResponseOfBlockOf {
    pageCount!: number;

    constructor(data?: IPagedResultResponseOfBlockOf) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultResponseOfBlockOf {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultResponseOfBlockOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCount"] = this.pageCount;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultResponseOfBlockOf extends IResultResponseOfBlockOf {
    pageCount: number;
}

export class Block implements IBlock {
    poolId!: string | undefined;
    blockHeight!: number;
    networkDifficulty!: number;
    status!: string | undefined;
    type!: string | undefined;
    confirmationProgress!: number;
    effort!: number | undefined;
    transactionConfirmationData!: string | undefined;
    reward!: number;
    infoLink!: string | undefined;
    hash!: string | undefined;
    miner!: string | undefined;
    source!: string | undefined;
    created!: moment.Moment;

    constructor(data?: IBlock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poolId = _data["poolId"];
            this.blockHeight = _data["blockHeight"];
            this.networkDifficulty = _data["networkDifficulty"];
            this.status = _data["status"];
            this.type = _data["type"];
            this.confirmationProgress = _data["confirmationProgress"];
            this.effort = _data["effort"];
            this.transactionConfirmationData = _data["transactionConfirmationData"];
            this.reward = _data["reward"];
            this.infoLink = _data["infoLink"];
            this.hash = _data["hash"];
            this.miner = _data["miner"];
            this.source = _data["source"];
            this.created = _data["created"] ? moment(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Block {
        data = typeof data === 'object' ? data : {};
        let result = new Block();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poolId"] = this.poolId;
        data["blockHeight"] = this.blockHeight;
        data["networkDifficulty"] = this.networkDifficulty;
        data["status"] = this.status;
        data["type"] = this.type;
        data["confirmationProgress"] = this.confirmationProgress;
        data["effort"] = this.effort;
        data["transactionConfirmationData"] = this.transactionConfirmationData;
        data["reward"] = this.reward;
        data["infoLink"] = this.infoLink;
        data["hash"] = this.hash;
        data["miner"] = this.miner;
        data["source"] = this.source;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBlock {
    poolId: string | undefined;
    blockHeight: number;
    networkDifficulty: number;
    status: string | undefined;
    type: string | undefined;
    confirmationProgress: number;
    effort: number | undefined;
    transactionConfirmationData: string | undefined;
    reward: number;
    infoLink: string | undefined;
    hash: string | undefined;
    miner: string | undefined;
    source: string | undefined;
    created: moment.Moment;
}

export enum ResponseMessageType {
    Info = 1,
    Warning = 2,
    Error = 3,
}

export class ResultResponseOfPaymentOf extends ResponseBase implements IResultResponseOfPaymentOf {
    result!: Payment[] | undefined;

    constructor(data?: IResultResponseOfPaymentOf) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(Payment.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultResponseOfPaymentOf {
        data = typeof data === 'object' ? data : {};
        let result = new ResultResponseOfPaymentOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultResponseOfPaymentOf extends IResponseBase {
    result: Payment[] | undefined;
}

export class PagedResultResponseOfPaymentOf extends ResultResponseOfPaymentOf implements IPagedResultResponseOfPaymentOf {
    pageCount!: number;

    constructor(data?: IPagedResultResponseOfPaymentOf) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultResponseOfPaymentOf {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultResponseOfPaymentOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCount"] = this.pageCount;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultResponseOfPaymentOf extends IResultResponseOfPaymentOf {
    pageCount: number;
}

export class Payment implements IPayment {
    coin!: string | undefined;
    address!: string | undefined;
    addressInfoLink!: string | undefined;
    amount!: number;
    transactionConfirmationData!: string | undefined;
    transactionInfoLink!: string | undefined;
    created!: moment.Moment;

    constructor(data?: IPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.coin = _data["coin"];
            this.address = _data["address"];
            this.addressInfoLink = _data["addressInfoLink"];
            this.amount = _data["amount"];
            this.transactionConfirmationData = _data["transactionConfirmationData"];
            this.transactionInfoLink = _data["transactionInfoLink"];
            this.created = _data["created"] ? moment(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): Payment {
        data = typeof data === 'object' ? data : {};
        let result = new Payment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["coin"] = this.coin;
        data["address"] = this.address;
        data["addressInfoLink"] = this.addressInfoLink;
        data["amount"] = this.amount;
        data["transactionConfirmationData"] = this.transactionConfirmationData;
        data["transactionInfoLink"] = this.transactionInfoLink;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPayment {
    coin: string | undefined;
    address: string | undefined;
    addressInfoLink: string | undefined;
    amount: number;
    transactionConfirmationData: string | undefined;
    transactionInfoLink: string | undefined;
    created: moment.Moment;
}

export class ResultResponseOfAmountByDateOf extends ResponseBase implements IResultResponseOfAmountByDateOf {
    result!: AmountByDate[] | undefined;

    constructor(data?: IResultResponseOfAmountByDateOf) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(AmountByDate.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultResponseOfAmountByDateOf {
        data = typeof data === 'object' ? data : {};
        let result = new ResultResponseOfAmountByDateOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultResponseOfAmountByDateOf extends IResponseBase {
    result: AmountByDate[] | undefined;
}

export class PagedResultResponseOfAmountByDateOf extends ResultResponseOfAmountByDateOf implements IPagedResultResponseOfAmountByDateOf {
    pageCount!: number;

    constructor(data?: IPagedResultResponseOfAmountByDateOf) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultResponseOfAmountByDateOf {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultResponseOfAmountByDateOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCount"] = this.pageCount;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultResponseOfAmountByDateOf extends IResultResponseOfAmountByDateOf {
    pageCount: number;
}

export class AmountByDate implements IAmountByDate {
    amount!: number;
    date!: moment.Moment;

    constructor(data?: IAmountByDate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.date = _data["date"] ? moment(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AmountByDate {
        data = typeof data === 'object' ? data : {};
        let result = new AmountByDate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAmountByDate {
    amount: number;
    date: moment.Moment;
}

export class ResultResponseOfBalanceChangeOf extends ResponseBase implements IResultResponseOfBalanceChangeOf {
    result!: BalanceChange[] | undefined;

    constructor(data?: IResultResponseOfBalanceChangeOf) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["result"])) {
                this.result = [] as any;
                for (let item of _data["result"])
                    this.result!.push(BalanceChange.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResultResponseOfBalanceChangeOf {
        data = typeof data === 'object' ? data : {};
        let result = new ResultResponseOfBalanceChangeOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.result)) {
            data["result"] = [];
            for (let item of this.result)
                data["result"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IResultResponseOfBalanceChangeOf extends IResponseBase {
    result: BalanceChange[] | undefined;
}

export class PagedResultResponseOfBalanceChangeOf extends ResultResponseOfBalanceChangeOf implements IPagedResultResponseOfBalanceChangeOf {
    pageCount!: number;

    constructor(data?: IPagedResultResponseOfBalanceChangeOf) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedResultResponseOfBalanceChangeOf {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultResponseOfBalanceChangeOf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageCount"] = this.pageCount;
        super.toJSON(data);
        return data;
    }
}

export interface IPagedResultResponseOfBalanceChangeOf extends IResultResponseOfBalanceChangeOf {
    pageCount: number;
}

export class BalanceChange implements IBalanceChange {
    poolId!: string | undefined;
    address!: string | undefined;
    amount!: number;
    usage!: string | undefined;
    created!: moment.Moment;

    constructor(data?: IBalanceChange) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poolId = _data["poolId"];
            this.address = _data["address"];
            this.amount = _data["amount"];
            this.usage = _data["usage"];
            this.created = _data["created"] ? moment(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): BalanceChange {
        data = typeof data === 'object' ? data : {};
        let result = new BalanceChange();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poolId"] = this.poolId;
        data["address"] = this.address;
        data["amount"] = this.amount;
        data["usage"] = this.usage;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IBalanceChange {
    poolId: string | undefined;
    address: string | undefined;
    amount: number;
    usage: string | undefined;
    created: moment.Moment;
}

export class ResultResponseOfMinerSettings extends ResponseBase implements IResultResponseOfMinerSettings {
    result!: MinerSettings | undefined;

    constructor(data?: IResultResponseOfMinerSettings) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? MinerSettings.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResultResponseOfMinerSettings {
        data = typeof data === 'object' ? data : {};
        let result = new ResultResponseOfMinerSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IResultResponseOfMinerSettings extends IResponseBase {
    result: MinerSettings | undefined;
}

export class MinerSettings implements IMinerSettings {
    paymentThreshold!: number;

    constructor(data?: IMinerSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentThreshold = _data["paymentThreshold"];
        }
    }

    static fromJS(data: any): MinerSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MinerSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentThreshold"] = this.paymentThreshold;
        return data;
    }
}

export interface IMinerSettings {
    paymentThreshold: number;
}

export class UpdateMinerSettingsRequest implements IUpdateMinerSettingsRequest {
    ipAddress!: string | undefined;
    settings!: MinerSettings | undefined;

    constructor(data?: IUpdateMinerSettingsRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ipAddress = _data["ipAddress"];
            this.settings = _data["settings"] ? MinerSettings.fromJS(_data["settings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateMinerSettingsRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateMinerSettingsRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ipAddress"] = this.ipAddress;
        data["settings"] = this.settings ? this.settings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateMinerSettingsRequest {
    ipAddress: string | undefined;
    settings: MinerSettings | undefined;
}

export class ResultResponseOfMinerStats extends ResponseBase implements IResultResponseOfMinerStats {
    result!: MinerStats | undefined;

    constructor(data?: IResultResponseOfMinerStats) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.result = _data["result"] ? MinerStats.fromJS(_data["result"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResultResponseOfMinerStats {
        data = typeof data === 'object' ? data : {};
        let result = new ResultResponseOfMinerStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result ? this.result.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IResultResponseOfMinerStats extends IResponseBase {
    result: MinerStats | undefined;
}

export class MinerStats implements IMinerStats {
    pendingShares!: number;
    pendingBalance!: number;
    totalPaid!: number;
    todayPaid!: number;
    lastPayment!: moment.Moment | undefined;
    lastPaymentLink!: string | undefined;
    performance!: WorkerPerformanceStatsContainer | undefined;
    performanceSamples!: WorkerPerformanceStatsContainer[] | undefined;

    constructor(data?: IMinerStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pendingShares = _data["pendingShares"];
            this.pendingBalance = _data["pendingBalance"];
            this.totalPaid = _data["totalPaid"];
            this.todayPaid = _data["todayPaid"];
            this.lastPayment = _data["lastPayment"] ? moment(_data["lastPayment"].toString()) : <any>undefined;
            this.lastPaymentLink = _data["lastPaymentLink"];
            this.performance = _data["performance"] ? WorkerPerformanceStatsContainer.fromJS(_data["performance"]) : <any>undefined;
            if (Array.isArray(_data["performanceSamples"])) {
                this.performanceSamples = [] as any;
                for (let item of _data["performanceSamples"])
                    this.performanceSamples!.push(WorkerPerformanceStatsContainer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MinerStats {
        data = typeof data === 'object' ? data : {};
        let result = new MinerStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pendingShares"] = this.pendingShares;
        data["pendingBalance"] = this.pendingBalance;
        data["totalPaid"] = this.totalPaid;
        data["todayPaid"] = this.todayPaid;
        data["lastPayment"] = this.lastPayment ? this.lastPayment.toISOString() : <any>undefined;
        data["lastPaymentLink"] = this.lastPaymentLink;
        data["performance"] = this.performance ? this.performance.toJSON() : <any>undefined;
        if (Array.isArray(this.performanceSamples)) {
            data["performanceSamples"] = [];
            for (let item of this.performanceSamples)
                data["performanceSamples"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMinerStats {
    pendingShares: number;
    pendingBalance: number;
    totalPaid: number;
    todayPaid: number;
    lastPayment: moment.Moment | undefined;
    lastPaymentLink: string | undefined;
    performance: WorkerPerformanceStatsContainer | undefined;
    performanceSamples: WorkerPerformanceStatsContainer[] | undefined;
}

export class WorkerPerformanceStatsContainer implements IWorkerPerformanceStatsContainer {
    created!: moment.Moment;
    workers!: { [key: string]: WorkerPerformanceStats; } | undefined;

    constructor(data?: IWorkerPerformanceStatsContainer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.created = _data["created"] ? moment(_data["created"].toString()) : <any>undefined;
            if (_data["workers"]) {
                this.workers = {} as any;
                for (let key in _data["workers"]) {
                    if (_data["workers"].hasOwnProperty(key))
                        (<any>this.workers)![key] = _data["workers"][key] ? WorkerPerformanceStats.fromJS(_data["workers"][key]) : new WorkerPerformanceStats();
                }
            }
        }
    }

    static fromJS(data: any): WorkerPerformanceStatsContainer {
        data = typeof data === 'object' ? data : {};
        let result = new WorkerPerformanceStatsContainer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        if (this.workers) {
            data["workers"] = {};
            for (let key in this.workers) {
                if (this.workers.hasOwnProperty(key))
                    (<any>data["workers"])[key] = this.workers[key] ? this.workers[key].toJSON() : <any>undefined;
            }
        }
        return data;
    }
}

export interface IWorkerPerformanceStatsContainer {
    created: moment.Moment;
    workers: { [key: string]: WorkerPerformanceStats; } | undefined;
}

export class WorkerPerformanceStats implements IWorkerPerformanceStats {
    hashrate!: number;
    sharesPerSecond!: number;

    constructor(data?: IWorkerPerformanceStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.hashrate = _data["hashrate"];
            this.sharesPerSecond = _data["sharesPerSecond"];
        }
    }

    static fromJS(data: any): WorkerPerformanceStats {
        data = typeof data === 'object' ? data : {};
        let result = new WorkerPerformanceStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["hashrate"] = this.hashrate;
        data["sharesPerSecond"] = this.sharesPerSecond;
        return data;
    }
}

export interface IWorkerPerformanceStats {
    hashrate: number;
    sharesPerSecond: number;
}

export enum SampleRange {
    Day = 1,
    Month = 2,
    Hour = 3,
}

export class AdminNotification implements IAdminNotification {
    subject!: string | undefined;
    message!: string | undefined;

    constructor(data?: IAdminNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subject = _data["subject"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): AdminNotification {
        data = typeof data === 'object' ? data : {};
        let result = new AdminNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["message"] = this.message;
        return data;
    }
}

export interface IAdminNotification {
    subject: string | undefined;
    message: string | undefined;
}

export abstract class BlockNotification implements IBlockNotification {
    poolId!: string | undefined;
    blockHeight!: number;
    symbol!: string | undefined;
    name!: string | undefined;

    constructor(data?: IBlockNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poolId = _data["poolId"];
            this.blockHeight = _data["blockHeight"];
            this.symbol = _data["symbol"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BlockNotification {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BlockNotification' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poolId"] = this.poolId;
        data["blockHeight"] = this.blockHeight;
        data["symbol"] = this.symbol;
        data["name"] = this.name;
        return data;
    }
}

export interface IBlockNotification {
    poolId: string | undefined;
    blockHeight: number;
    symbol: string | undefined;
    name: string | undefined;
}

export class BlockFoundNotification extends BlockNotification implements IBlockFoundNotification {
    miner!: string | undefined;
    minerExplorerLink!: string | undefined;
    source!: string | undefined;

    constructor(data?: IBlockFoundNotification) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.miner = _data["miner"];
            this.minerExplorerLink = _data["minerExplorerLink"];
            this.source = _data["source"];
        }
    }

    static fromJS(data: any): BlockFoundNotification {
        data = typeof data === 'object' ? data : {};
        let result = new BlockFoundNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["miner"] = this.miner;
        data["minerExplorerLink"] = this.minerExplorerLink;
        data["source"] = this.source;
        super.toJSON(data);
        return data;
    }
}

export interface IBlockFoundNotification extends IBlockNotification {
    miner: string | undefined;
    minerExplorerLink: string | undefined;
    source: string | undefined;
}

export class NewChainHeightNotification extends BlockNotification implements INewChainHeightNotification {

    constructor(data?: INewChainHeightNotification) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): NewChainHeightNotification {
        data = typeof data === 'object' ? data : {};
        let result = new NewChainHeightNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface INewChainHeightNotification extends IBlockNotification {
}

export class BlockConfirmationProgressNotification extends BlockNotification implements IBlockConfirmationProgressNotification {
    progress!: number;
    effort!: number | undefined;

    constructor(data?: IBlockConfirmationProgressNotification) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.progress = _data["progress"];
            this.effort = _data["effort"];
        }
    }

    static fromJS(data: any): BlockConfirmationProgressNotification {
        data = typeof data === 'object' ? data : {};
        let result = new BlockConfirmationProgressNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["progress"] = this.progress;
        data["effort"] = this.effort;
        super.toJSON(data);
        return data;
    }
}

export interface IBlockConfirmationProgressNotification extends IBlockNotification {
    progress: number;
    effort: number | undefined;
}

export class BlockUnlockedNotification extends BlockNotification implements IBlockUnlockedNotification {
    status!: BlockStatus2;
    blockType!: string | undefined;
    blockHash!: string | undefined;
    reward!: number;
    effort!: number | undefined;
    miner!: string | undefined;
    explorerLink!: string | undefined;
    minerExplorerLink!: string | undefined;

    constructor(data?: IBlockUnlockedNotification) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.status = _data["status"];
            this.blockType = _data["blockType"];
            this.blockHash = _data["blockHash"];
            this.reward = _data["reward"];
            this.effort = _data["effort"];
            this.miner = _data["miner"];
            this.explorerLink = _data["explorerLink"];
            this.minerExplorerLink = _data["minerExplorerLink"];
        }
    }

    static fromJS(data: any): BlockUnlockedNotification {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUnlockedNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["blockType"] = this.blockType;
        data["blockHash"] = this.blockHash;
        data["reward"] = this.reward;
        data["effort"] = this.effort;
        data["miner"] = this.miner;
        data["explorerLink"] = this.explorerLink;
        data["minerExplorerLink"] = this.minerExplorerLink;
        super.toJSON(data);
        return data;
    }
}

export interface IBlockUnlockedNotification extends IBlockNotification {
    status: BlockStatus2;
    blockType: string | undefined;
    blockHash: string | undefined;
    reward: number;
    effort: number | undefined;
    miner: string | undefined;
    explorerLink: string | undefined;
    minerExplorerLink: string | undefined;
}

export enum BlockStatus2 {
    Pending = "Pending",
    Orphaned = "Orphaned",
    Confirmed = "Confirmed",
}

export class HashrateNotification implements IHashrateNotification {
    poolId!: string | undefined;
    hashrate!: number;
    miner!: string | undefined;
    worker!: string | undefined;

    constructor(data?: IHashrateNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poolId = _data["poolId"];
            this.hashrate = _data["hashrate"];
            this.miner = _data["miner"];
            this.worker = _data["worker"];
        }
    }

    static fromJS(data: any): HashrateNotification {
        data = typeof data === 'object' ? data : {};
        let result = new HashrateNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poolId"] = this.poolId;
        data["hashrate"] = this.hashrate;
        data["miner"] = this.miner;
        data["worker"] = this.worker;
        return data;
    }
}

export interface IHashrateNotification {
    poolId: string | undefined;
    hashrate: number;
    miner: string | undefined;
    worker: string | undefined;
}

export class PaymentNotification implements IPaymentNotification {
    poolId!: string | undefined;
    txFee!: number | undefined;
    txIds!: string[] | undefined;
    txExplorerLinks!: string[] | undefined;
    symbol!: string | undefined;
    recpientsCount!: number;
    amount!: number;
    error!: string | undefined;

    constructor(data?: IPaymentNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poolId = _data["poolId"];
            this.txFee = _data["txFee"];
            if (Array.isArray(_data["txIds"])) {
                this.txIds = [] as any;
                for (let item of _data["txIds"])
                    this.txIds!.push(item);
            }
            if (Array.isArray(_data["txExplorerLinks"])) {
                this.txExplorerLinks = [] as any;
                for (let item of _data["txExplorerLinks"])
                    this.txExplorerLinks!.push(item);
            }
            this.symbol = _data["symbol"];
            this.recpientsCount = _data["recpientsCount"];
            this.amount = _data["amount"];
            this.error = _data["error"];
        }
    }

    static fromJS(data: any): PaymentNotification {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poolId"] = this.poolId;
        data["txFee"] = this.txFee;
        if (Array.isArray(this.txIds)) {
            data["txIds"] = [];
            for (let item of this.txIds)
                data["txIds"].push(item);
        }
        if (Array.isArray(this.txExplorerLinks)) {
            data["txExplorerLinks"] = [];
            for (let item of this.txExplorerLinks)
                data["txExplorerLinks"].push(item);
        }
        data["symbol"] = this.symbol;
        data["recpientsCount"] = this.recpientsCount;
        data["amount"] = this.amount;
        data["error"] = this.error;
        return data;
    }
}

export interface IPaymentNotification {
    poolId: string | undefined;
    txFee: number | undefined;
    txIds: string[] | undefined;
    txExplorerLinks: string[] | undefined;
    symbol: string | undefined;
    recpientsCount: number;
    amount: number;
    error: string | undefined;
}

export class PoolStatusNotification implements IPoolStatusNotification {
    pool!: IMiningPool | undefined;
    status!: PoolStatus;

    constructor(data?: IPoolStatusNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pool = _data["pool"] ? IMiningPool.fromJS(_data["pool"]) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): PoolStatusNotification {
        data = typeof data === 'object' ? data : {};
        let result = new PoolStatusNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pool"] = this.pool ? this.pool.toJSON() : <any>undefined;
        data["status"] = this.status;
        return data;
    }
}

export interface IPoolStatusNotification {
    pool: IMiningPool | undefined;
    status: PoolStatus;
}

export abstract class IMiningPool implements IIMiningPool {
    config!: PoolConfig | undefined;
    poolStats!: PoolStats | undefined;
    networkStats!: BlockchainStats | undefined;
    shareMultiplier!: number;

    constructor(data?: IIMiningPool) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.config = _data["config"] ? PoolConfig.fromJS(_data["config"]) : <any>undefined;
            this.poolStats = _data["poolStats"] ? PoolStats.fromJS(_data["poolStats"]) : <any>undefined;
            this.networkStats = _data["networkStats"] ? BlockchainStats.fromJS(_data["networkStats"]) : <any>undefined;
            this.shareMultiplier = _data["shareMultiplier"];
        }
    }

    static fromJS(data: any): IMiningPool {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IMiningPool' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["config"] = this.config ? this.config.toJSON() : <any>undefined;
        data["poolStats"] = this.poolStats ? this.poolStats.toJSON() : <any>undefined;
        data["networkStats"] = this.networkStats ? this.networkStats.toJSON() : <any>undefined;
        data["shareMultiplier"] = this.shareMultiplier;
        return data;
    }
}

export interface IIMiningPool {
    config: PoolConfig | undefined;
    poolStats: PoolStats | undefined;
    networkStats: BlockchainStats | undefined;
    shareMultiplier: number;
}

export class PoolConfig implements IPoolConfig {
    id!: string;
    coin!: string;
    enabled!: boolean;
    ports!: { [key: string]: PoolEndpoint; };
    daemons!: DaemonEndpointConfig[];
    paymentProcessing!: PoolPaymentProcessingConfig | undefined;
    banning!: PoolShareBasedBanningConfig | undefined;
    rewardRecipients!: RewardRecipient[] | undefined;
    address!: string | undefined;
    pubKey!: string | undefined;
    clientConnectionTimeout!: number;
    jobRebroadcastTimeout!: number;
    blockRefreshInterval!: number;
    enableInternalStratum!: boolean | undefined;
    extra!: { [key: string]: any; } | undefined;
    template!: CoinTemplate | undefined;
    additionalProperties!: { [key: string]: any; } | undefined;

    constructor(data?: IPoolConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.ports = {};
            this.daemons = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.coin = _data["coin"];
            this.enabled = _data["enabled"];
            if (_data["ports"]) {
                this.ports = {} as any;
                for (let key in _data["ports"]) {
                    if (_data["ports"].hasOwnProperty(key))
                        (<any>this.ports)![key] = _data["ports"][key] ? PoolEndpoint.fromJS(_data["ports"][key]) : new PoolEndpoint();
                }
            }
            if (Array.isArray(_data["daemons"])) {
                this.daemons = [] as any;
                for (let item of _data["daemons"])
                    this.daemons!.push(DaemonEndpointConfig.fromJS(item));
            }
            this.paymentProcessing = _data["paymentProcessing"] ? PoolPaymentProcessingConfig.fromJS(_data["paymentProcessing"]) : <any>undefined;
            this.banning = _data["banning"] ? PoolShareBasedBanningConfig.fromJS(_data["banning"]) : <any>undefined;
            if (Array.isArray(_data["rewardRecipients"])) {
                this.rewardRecipients = [] as any;
                for (let item of _data["rewardRecipients"])
                    this.rewardRecipients!.push(RewardRecipient.fromJS(item));
            }
            this.address = _data["address"];
            this.pubKey = _data["pubKey"];
            this.clientConnectionTimeout = _data["clientConnectionTimeout"];
            this.jobRebroadcastTimeout = _data["jobRebroadcastTimeout"];
            this.blockRefreshInterval = _data["blockRefreshInterval"];
            this.enableInternalStratum = _data["enableInternalStratum"];
            if (_data["extra"]) {
                this.extra = {} as any;
                for (let key in _data["extra"]) {
                    if (_data["extra"].hasOwnProperty(key))
                        (<any>this.extra)![key] = _data["extra"][key];
                }
            }
            this.template = _data["template"] ? CoinTemplate.fromJS(_data["template"]) : <any>undefined;
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PoolConfig {
        data = typeof data === 'object' ? data : {};
        let result = new PoolConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coin"] = this.coin;
        data["enabled"] = this.enabled;
        if (this.ports) {
            data["ports"] = {};
            for (let key in this.ports) {
                if (this.ports.hasOwnProperty(key))
                    (<any>data["ports"])[key] = this.ports[key] ? this.ports[key].toJSON() : <any>undefined;
            }
        }
        if (Array.isArray(this.daemons)) {
            data["daemons"] = [];
            for (let item of this.daemons)
                data["daemons"].push(item.toJSON());
        }
        data["paymentProcessing"] = this.paymentProcessing ? this.paymentProcessing.toJSON() : <any>undefined;
        data["banning"] = this.banning ? this.banning.toJSON() : <any>undefined;
        if (Array.isArray(this.rewardRecipients)) {
            data["rewardRecipients"] = [];
            for (let item of this.rewardRecipients)
                data["rewardRecipients"].push(item.toJSON());
        }
        data["address"] = this.address;
        data["pubKey"] = this.pubKey;
        data["clientConnectionTimeout"] = this.clientConnectionTimeout;
        data["jobRebroadcastTimeout"] = this.jobRebroadcastTimeout;
        data["blockRefreshInterval"] = this.blockRefreshInterval;
        data["enableInternalStratum"] = this.enableInternalStratum;
        if (this.extra) {
            data["extra"] = {};
            for (let key in this.extra) {
                if (this.extra.hasOwnProperty(key))
                    (<any>data["extra"])[key] = this.extra[key];
            }
        }
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IPoolConfig {
    id: string;
    coin: string;
    enabled: boolean;
    ports: { [key: string]: PoolEndpoint; };
    daemons: DaemonEndpointConfig[];
    paymentProcessing: PoolPaymentProcessingConfig | undefined;
    banning: PoolShareBasedBanningConfig | undefined;
    rewardRecipients: RewardRecipient[] | undefined;
    address: string | undefined;
    pubKey: string | undefined;
    clientConnectionTimeout: number;
    jobRebroadcastTimeout: number;
    blockRefreshInterval: number;
    enableInternalStratum: boolean | undefined;
    extra: { [key: string]: any; } | undefined;
    template: CoinTemplate | undefined;
    additionalProperties: { [key: string]: any; } | undefined;
}

export class PoolEndpoint implements IPoolEndpoint {
    listenAddress!: string | undefined;
    name!: string | undefined;
    difficulty!: number;
    tcpProxyProtocol!: TcpProxyProtocolConfig | undefined;
    varDiff!: VarDiffConfig | undefined;
    tls!: boolean;
    tlsAuto!: boolean;
    tlsPfxFile!: string | undefined;
    tlsPfxPassword!: string | undefined;

    constructor(data?: IPoolEndpoint) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listenAddress = _data["listenAddress"];
            this.name = _data["name"];
            this.difficulty = _data["difficulty"];
            this.tcpProxyProtocol = _data["tcpProxyProtocol"] ? TcpProxyProtocolConfig.fromJS(_data["tcpProxyProtocol"]) : <any>undefined;
            this.varDiff = _data["varDiff"] ? VarDiffConfig.fromJS(_data["varDiff"]) : <any>undefined;
            this.tls = _data["tls"];
            this.tlsAuto = _data["tlsAuto"];
            this.tlsPfxFile = _data["tlsPfxFile"];
            this.tlsPfxPassword = _data["tlsPfxPassword"];
        }
    }

    static fromJS(data: any): PoolEndpoint {
        data = typeof data === 'object' ? data : {};
        let result = new PoolEndpoint();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listenAddress"] = this.listenAddress;
        data["name"] = this.name;
        data["difficulty"] = this.difficulty;
        data["tcpProxyProtocol"] = this.tcpProxyProtocol ? this.tcpProxyProtocol.toJSON() : <any>undefined;
        data["varDiff"] = this.varDiff ? this.varDiff.toJSON() : <any>undefined;
        data["tls"] = this.tls;
        data["tlsAuto"] = this.tlsAuto;
        data["tlsPfxFile"] = this.tlsPfxFile;
        data["tlsPfxPassword"] = this.tlsPfxPassword;
        return data;
    }
}

export interface IPoolEndpoint {
    listenAddress: string | undefined;
    name: string | undefined;
    difficulty: number;
    tcpProxyProtocol: TcpProxyProtocolConfig | undefined;
    varDiff: VarDiffConfig | undefined;
    tls: boolean;
    tlsAuto: boolean;
    tlsPfxFile: string | undefined;
    tlsPfxPassword: string | undefined;
}

export class TcpProxyProtocolConfig implements ITcpProxyProtocolConfig {
    enable!: boolean;
    mandatory!: boolean;
    proxyAddresses!: string[] | undefined;

    constructor(data?: ITcpProxyProtocolConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enable = _data["enable"];
            this.mandatory = _data["mandatory"];
            if (Array.isArray(_data["proxyAddresses"])) {
                this.proxyAddresses = [] as any;
                for (let item of _data["proxyAddresses"])
                    this.proxyAddresses!.push(item);
            }
        }
    }

    static fromJS(data: any): TcpProxyProtocolConfig {
        data = typeof data === 'object' ? data : {};
        let result = new TcpProxyProtocolConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enable"] = this.enable;
        data["mandatory"] = this.mandatory;
        if (Array.isArray(this.proxyAddresses)) {
            data["proxyAddresses"] = [];
            for (let item of this.proxyAddresses)
                data["proxyAddresses"].push(item);
        }
        return data;
    }
}

export interface ITcpProxyProtocolConfig {
    enable: boolean;
    mandatory: boolean;
    proxyAddresses: string[] | undefined;
}

export class VarDiffConfig implements IVarDiffConfig {
    minDiff!: number;
    maxDiff!: number | undefined;
    maxDelta!: number | undefined;
    targetTime!: number;
    retargetTime!: number;
    variancePercent!: number;

    constructor(data?: IVarDiffConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.minDiff = _data["minDiff"];
            this.maxDiff = _data["maxDiff"];
            this.maxDelta = _data["maxDelta"];
            this.targetTime = _data["targetTime"];
            this.retargetTime = _data["retargetTime"];
            this.variancePercent = _data["variancePercent"];
        }
    }

    static fromJS(data: any): VarDiffConfig {
        data = typeof data === 'object' ? data : {};
        let result = new VarDiffConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["minDiff"] = this.minDiff;
        data["maxDiff"] = this.maxDiff;
        data["maxDelta"] = this.maxDelta;
        data["targetTime"] = this.targetTime;
        data["retargetTime"] = this.retargetTime;
        data["variancePercent"] = this.variancePercent;
        return data;
    }
}

export interface IVarDiffConfig {
    minDiff: number;
    maxDiff: number | undefined;
    maxDelta: number | undefined;
    targetTime: number;
    retargetTime: number;
    variancePercent: number;
}

export class NetworkEndpointConfig implements INetworkEndpointConfig {
    host!: string | undefined;
    port!: number;

    constructor(data?: INetworkEndpointConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.host = _data["host"];
            this.port = _data["port"];
        }
    }

    static fromJS(data: any): NetworkEndpointConfig {
        data = typeof data === 'object' ? data : {};
        let result = new NetworkEndpointConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["host"] = this.host;
        data["port"] = this.port;
        return data;
    }
}

export interface INetworkEndpointConfig {
    host: string | undefined;
    port: number;
}

export class AuthenticatedNetworkEndpointConfig extends NetworkEndpointConfig implements IAuthenticatedNetworkEndpointConfig {
    user!: string | undefined;
    password!: string | undefined;

    constructor(data?: IAuthenticatedNetworkEndpointConfig) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.user = _data["user"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticatedNetworkEndpointConfig {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticatedNetworkEndpointConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user;
        data["password"] = this.password;
        super.toJSON(data);
        return data;
    }
}

export interface IAuthenticatedNetworkEndpointConfig extends INetworkEndpointConfig {
    user: string | undefined;
    password: string | undefined;
}

export class DaemonEndpointConfig extends AuthenticatedNetworkEndpointConfig implements IDaemonEndpointConfig {
    ssl!: boolean;
    http2!: boolean;
    category!: string | undefined;
    httpPath!: string | undefined;
    extra!: { [key: string]: any; } | undefined;
    additionalProperties!: { [key: string]: any; } | undefined;

    constructor(data?: IDaemonEndpointConfig) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.ssl = _data["ssl"];
            this.http2 = _data["http2"];
            this.category = _data["category"];
            this.httpPath = _data["httpPath"];
            if (_data["extra"]) {
                this.extra = {} as any;
                for (let key in _data["extra"]) {
                    if (_data["extra"].hasOwnProperty(key))
                        (<any>this.extra)![key] = _data["extra"][key];
                }
            }
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): DaemonEndpointConfig {
        data = typeof data === 'object' ? data : {};
        let result = new DaemonEndpointConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ssl"] = this.ssl;
        data["http2"] = this.http2;
        data["category"] = this.category;
        data["httpPath"] = this.httpPath;
        if (this.extra) {
            data["extra"] = {};
            for (let key in this.extra) {
                if (this.extra.hasOwnProperty(key))
                    (<any>data["extra"])[key] = this.extra[key];
            }
        }
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IDaemonEndpointConfig extends IAuthenticatedNetworkEndpointConfig {
    ssl: boolean;
    http2: boolean;
    category: string | undefined;
    httpPath: string | undefined;
    extra: { [key: string]: any; } | undefined;
    additionalProperties: { [key: string]: any; } | undefined;
}

export class PoolPaymentProcessingConfig implements IPoolPaymentProcessingConfig {
    enabled!: boolean;
    minimumPayment!: number;
    payoutScheme!: PayoutScheme;
    payoutSchemeConfig!: any | undefined;
    extra!: { [key: string]: any; } | undefined;
    additionalProperties!: { [key: string]: any; } | undefined;

    constructor(data?: IPoolPaymentProcessingConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enabled = _data["enabled"];
            this.minimumPayment = _data["minimumPayment"];
            this.payoutScheme = _data["payoutScheme"];
            this.payoutSchemeConfig = _data["payoutSchemeConfig"];
            if (_data["extra"]) {
                this.extra = {} as any;
                for (let key in _data["extra"]) {
                    if (_data["extra"].hasOwnProperty(key))
                        (<any>this.extra)![key] = _data["extra"][key];
                }
            }
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): PoolPaymentProcessingConfig {
        data = typeof data === 'object' ? data : {};
        let result = new PoolPaymentProcessingConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["minimumPayment"] = this.minimumPayment;
        data["payoutScheme"] = this.payoutScheme;
        data["payoutSchemeConfig"] = this.payoutSchemeConfig;
        if (this.extra) {
            data["extra"] = {};
            for (let key in this.extra) {
                if (this.extra.hasOwnProperty(key))
                    (<any>data["extra"])[key] = this.extra[key];
            }
        }
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IPoolPaymentProcessingConfig {
    enabled: boolean;
    minimumPayment: number;
    payoutScheme: PayoutScheme;
    payoutSchemeConfig: any | undefined;
    extra: { [key: string]: any; } | undefined;
    additionalProperties: { [key: string]: any; } | undefined;
}

export enum PayoutScheme {
    PPLNS = 1,
    PROP = 2,
    SOLO = 3,
    PPS = 4,
    PPBS = 5,
}

export class PoolShareBasedBanningConfig implements IPoolShareBasedBanningConfig {
    enabled!: boolean;
    checkThreshold!: number;
    invalidPercent!: number;
    time!: number;

    constructor(data?: IPoolShareBasedBanningConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enabled = _data["enabled"];
            this.checkThreshold = _data["checkThreshold"];
            this.invalidPercent = _data["invalidPercent"];
            this.time = _data["time"];
        }
    }

    static fromJS(data: any): PoolShareBasedBanningConfig {
        data = typeof data === 'object' ? data : {};
        let result = new PoolShareBasedBanningConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["checkThreshold"] = this.checkThreshold;
        data["invalidPercent"] = this.invalidPercent;
        data["time"] = this.time;
        return data;
    }
}

export interface IPoolShareBasedBanningConfig {
    enabled: boolean;
    checkThreshold: number;
    invalidPercent: number;
    time: number;
}

export class RewardRecipient implements IRewardRecipient {
    address!: string | undefined;
    percentage!: number;
    type!: string | undefined;

    constructor(data?: IRewardRecipient) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.address = _data["address"];
            this.percentage = _data["percentage"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): RewardRecipient {
        data = typeof data === 'object' ? data : {};
        let result = new RewardRecipient();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address;
        data["percentage"] = this.percentage;
        data["type"] = this.type;
        return data;
    }
}

export interface IRewardRecipient {
    address: string | undefined;
    percentage: number;
    type: string | undefined;
}

export abstract class CoinTemplate implements ICoinTemplate {
    name!: string | undefined;
    symbol!: string | undefined;
    website!: string | undefined;
    twitter!: string | undefined;
    discord!: string | undefined;
    telegram!: string | undefined;
    family!: CoinFamily;
    canonicalName!: string | undefined;
    explorerBlockLinks!: { [key: string]: string; } | undefined;
    explorerBlockLink!: string | undefined;
    explorerTxLink!: string | undefined;
    explorerAccountLink!: string | undefined;
    extra!: { [key: string]: any; } | undefined;
    source!: string | undefined;
    additionalProperties!: { [key: string]: any; } | undefined;

    constructor(data?: ICoinTemplate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.symbol = _data["symbol"];
            this.website = _data["website"];
            this.twitter = _data["twitter"];
            this.discord = _data["discord"];
            this.telegram = _data["telegram"];
            this.family = _data["family"];
            this.canonicalName = _data["canonicalName"];
            if (_data["explorerBlockLinks"]) {
                this.explorerBlockLinks = {} as any;
                for (let key in _data["explorerBlockLinks"]) {
                    if (_data["explorerBlockLinks"].hasOwnProperty(key))
                        (<any>this.explorerBlockLinks)![key] = _data["explorerBlockLinks"][key];
                }
            }
            this.explorerBlockLink = _data["explorerBlockLink"];
            this.explorerTxLink = _data["explorerTxLink"];
            this.explorerAccountLink = _data["explorerAccountLink"];
            if (_data["extra"]) {
                this.extra = {} as any;
                for (let key in _data["extra"]) {
                    if (_data["extra"].hasOwnProperty(key))
                        (<any>this.extra)![key] = _data["extra"][key];
                }
            }
            this.source = _data["source"];
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): CoinTemplate {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'CoinTemplate' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["website"] = this.website;
        data["twitter"] = this.twitter;
        data["discord"] = this.discord;
        data["telegram"] = this.telegram;
        data["family"] = this.family;
        data["canonicalName"] = this.canonicalName;
        if (this.explorerBlockLinks) {
            data["explorerBlockLinks"] = {};
            for (let key in this.explorerBlockLinks) {
                if (this.explorerBlockLinks.hasOwnProperty(key))
                    (<any>data["explorerBlockLinks"])[key] = this.explorerBlockLinks[key];
            }
        }
        data["explorerBlockLink"] = this.explorerBlockLink;
        data["explorerTxLink"] = this.explorerTxLink;
        data["explorerAccountLink"] = this.explorerAccountLink;
        if (this.extra) {
            data["extra"] = {};
            for (let key in this.extra) {
                if (this.extra.hasOwnProperty(key))
                    (<any>data["extra"])[key] = this.extra[key];
            }
        }
        data["source"] = this.source;
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface ICoinTemplate {
    name: string | undefined;
    symbol: string | undefined;
    website: string | undefined;
    twitter: string | undefined;
    discord: string | undefined;
    telegram: string | undefined;
    family: CoinFamily;
    canonicalName: string | undefined;
    explorerBlockLinks: { [key: string]: string; } | undefined;
    explorerBlockLink: string | undefined;
    explorerTxLink: string | undefined;
    explorerAccountLink: string | undefined;
    extra: { [key: string]: any; } | undefined;
    source: string | undefined;
    additionalProperties: { [key: string]: any; } | undefined;
}

export enum CoinFamily {
    Bitcoin = "bitcoin",
    Equihash = "equihash",
    Cryptonote = "cryptonote",
    Ethereum = "ethereum",
    Ergo = "ergo",
}

export class PoolStats implements IPoolStats {
    lastPoolBlockTime!: moment.Moment | undefined;
    connectedMiners!: number;
    poolHashrate!: number;
    sharesPerSecond!: number;

    constructor(data?: IPoolStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastPoolBlockTime = _data["lastPoolBlockTime"] ? moment(_data["lastPoolBlockTime"].toString()) : <any>undefined;
            this.connectedMiners = _data["connectedMiners"];
            this.poolHashrate = _data["poolHashrate"];
            this.sharesPerSecond = _data["sharesPerSecond"];
        }
    }

    static fromJS(data: any): PoolStats {
        data = typeof data === 'object' ? data : {};
        let result = new PoolStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastPoolBlockTime"] = this.lastPoolBlockTime ? this.lastPoolBlockTime.toISOString() : <any>undefined;
        data["connectedMiners"] = this.connectedMiners;
        data["poolHashrate"] = this.poolHashrate;
        data["sharesPerSecond"] = this.sharesPerSecond;
        return data;
    }
}

export interface IPoolStats {
    lastPoolBlockTime: moment.Moment | undefined;
    connectedMiners: number;
    poolHashrate: number;
    sharesPerSecond: number;
}

export class BlockchainStats implements IBlockchainStats {
    networkType!: string | undefined;
    networkHashrate!: number;
    networkDifficulty!: number;
    nextNetworkTarget!: string | undefined;
    nextNetworkBits!: string | undefined;
    lastNetworkBlockTime!: moment.Moment | undefined;
    blockHeight!: number;
    connectedPeers!: number;
    rewardType!: string | undefined;

    constructor(data?: IBlockchainStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.networkType = _data["networkType"];
            this.networkHashrate = _data["networkHashrate"];
            this.networkDifficulty = _data["networkDifficulty"];
            this.nextNetworkTarget = _data["nextNetworkTarget"];
            this.nextNetworkBits = _data["nextNetworkBits"];
            this.lastNetworkBlockTime = _data["lastNetworkBlockTime"] ? moment(_data["lastNetworkBlockTime"].toString()) : <any>undefined;
            this.blockHeight = _data["blockHeight"];
            this.connectedPeers = _data["connectedPeers"];
            this.rewardType = _data["rewardType"];
        }
    }

    static fromJS(data: any): BlockchainStats {
        data = typeof data === 'object' ? data : {};
        let result = new BlockchainStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["networkType"] = this.networkType;
        data["networkHashrate"] = this.networkHashrate;
        data["networkDifficulty"] = this.networkDifficulty;
        data["nextNetworkTarget"] = this.nextNetworkTarget;
        data["nextNetworkBits"] = this.nextNetworkBits;
        data["lastNetworkBlockTime"] = this.lastNetworkBlockTime ? this.lastNetworkBlockTime.toISOString() : <any>undefined;
        data["blockHeight"] = this.blockHeight;
        data["connectedPeers"] = this.connectedPeers;
        data["rewardType"] = this.rewardType;
        return data;
    }
}

export interface IBlockchainStats {
    networkType: string | undefined;
    networkHashrate: number;
    networkDifficulty: number;
    nextNetworkTarget: string | undefined;
    nextNetworkBits: string | undefined;
    lastNetworkBlockTime: moment.Moment | undefined;
    blockHeight: number;
    connectedPeers: number;
    rewardType: string | undefined;
}

export enum PoolStatus {
    Online = 0,
    Offline = 1,
}

export class LiveDashboardModel implements ILiveDashboardModel {
    blocks!: Block[] | undefined;
    poolIds!: string[] | undefined;
    poolIcons!: { [key: string]: string; } | undefined;
    poolNames!: { [key: string]: string; } | undefined;
    poolSymbols!: { [key: string]: string; } | undefined;
    otherPools!: PoolInfo[] | undefined;

    constructor(data?: ILiveDashboardModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["blocks"])) {
                this.blocks = [] as any;
                for (let item of _data["blocks"])
                    this.blocks!.push(Block.fromJS(item));
            }
            if (Array.isArray(_data["poolIds"])) {
                this.poolIds = [] as any;
                for (let item of _data["poolIds"])
                    this.poolIds!.push(item);
            }
            if (_data["poolIcons"]) {
                this.poolIcons = {} as any;
                for (let key in _data["poolIcons"]) {
                    if (_data["poolIcons"].hasOwnProperty(key))
                        (<any>this.poolIcons)![key] = _data["poolIcons"][key];
                }
            }
            if (_data["poolNames"]) {
                this.poolNames = {} as any;
                for (let key in _data["poolNames"]) {
                    if (_data["poolNames"].hasOwnProperty(key))
                        (<any>this.poolNames)![key] = _data["poolNames"][key];
                }
            }
            if (_data["poolSymbols"]) {
                this.poolSymbols = {} as any;
                for (let key in _data["poolSymbols"]) {
                    if (_data["poolSymbols"].hasOwnProperty(key))
                        (<any>this.poolSymbols)![key] = _data["poolSymbols"][key];
                }
            }
            if (Array.isArray(_data["otherPools"])) {
                this.otherPools = [] as any;
                for (let item of _data["otherPools"])
                    this.otherPools!.push(PoolInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LiveDashboardModel {
        data = typeof data === 'object' ? data : {};
        let result = new LiveDashboardModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.blocks)) {
            data["blocks"] = [];
            for (let item of this.blocks)
                data["blocks"].push(item.toJSON());
        }
        if (Array.isArray(this.poolIds)) {
            data["poolIds"] = [];
            for (let item of this.poolIds)
                data["poolIds"].push(item);
        }
        if (this.poolIcons) {
            data["poolIcons"] = {};
            for (let key in this.poolIcons) {
                if (this.poolIcons.hasOwnProperty(key))
                    (<any>data["poolIcons"])[key] = this.poolIcons[key];
            }
        }
        if (this.poolNames) {
            data["poolNames"] = {};
            for (let key in this.poolNames) {
                if (this.poolNames.hasOwnProperty(key))
                    (<any>data["poolNames"])[key] = this.poolNames[key];
            }
        }
        if (this.poolSymbols) {
            data["poolSymbols"] = {};
            for (let key in this.poolSymbols) {
                if (this.poolSymbols.hasOwnProperty(key))
                    (<any>data["poolSymbols"])[key] = this.poolSymbols[key];
            }
        }
        if (Array.isArray(this.otherPools)) {
            data["otherPools"] = [];
            for (let item of this.otherPools)
                data["otherPools"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILiveDashboardModel {
    blocks: Block[] | undefined;
    poolIds: string[] | undefined;
    poolIcons: { [key: string]: string; } | undefined;
    poolNames: { [key: string]: string; } | undefined;
    poolSymbols: { [key: string]: string; } | undefined;
    otherPools: PoolInfo[] | undefined;
}

export class PoolInfo implements IPoolInfo {
    id!: string | undefined;
    coin!: ApiCoinConfig | undefined;
    ports!: { [key: string]: PoolEndpoint; } | undefined;
    paymentProcessing!: ApiPoolPaymentProcessingConfig | undefined;
    shareBasedBanning!: PoolShareBasedBanningConfig | undefined;
    clientConnectionTimeout!: number;
    jobRebroadcastTimeout!: number;
    blockRefreshInterval!: number;
    poolFeePercent!: number;
    address!: string | undefined;
    addressInfoLink!: string | undefined;
    poolStats!: PoolStats | undefined;
    networkStats!: BlockchainStats | undefined;
    topMiners!: MinerPerformanceStats[] | undefined;
    totalPaid!: number;
    totalBlocks!: number;
    lastPoolBlockTime!: moment.Moment | undefined;
    apiEndpoint!: string | undefined;

    constructor(data?: IPoolInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.coin = _data["coin"] ? ApiCoinConfig.fromJS(_data["coin"]) : <any>undefined;
            if (_data["ports"]) {
                this.ports = {} as any;
                for (let key in _data["ports"]) {
                    if (_data["ports"].hasOwnProperty(key))
                        (<any>this.ports)![key] = _data["ports"][key] ? PoolEndpoint.fromJS(_data["ports"][key]) : new PoolEndpoint();
                }
            }
            this.paymentProcessing = _data["paymentProcessing"] ? ApiPoolPaymentProcessingConfig.fromJS(_data["paymentProcessing"]) : <any>undefined;
            this.shareBasedBanning = _data["shareBasedBanning"] ? PoolShareBasedBanningConfig.fromJS(_data["shareBasedBanning"]) : <any>undefined;
            this.clientConnectionTimeout = _data["clientConnectionTimeout"];
            this.jobRebroadcastTimeout = _data["jobRebroadcastTimeout"];
            this.blockRefreshInterval = _data["blockRefreshInterval"];
            this.poolFeePercent = _data["poolFeePercent"];
            this.address = _data["address"];
            this.addressInfoLink = _data["addressInfoLink"];
            this.poolStats = _data["poolStats"] ? PoolStats.fromJS(_data["poolStats"]) : <any>undefined;
            this.networkStats = _data["networkStats"] ? BlockchainStats.fromJS(_data["networkStats"]) : <any>undefined;
            if (Array.isArray(_data["topMiners"])) {
                this.topMiners = [] as any;
                for (let item of _data["topMiners"])
                    this.topMiners!.push(MinerPerformanceStats.fromJS(item));
            }
            this.totalPaid = _data["totalPaid"];
            this.totalBlocks = _data["totalBlocks"];
            this.lastPoolBlockTime = _data["lastPoolBlockTime"] ? moment(_data["lastPoolBlockTime"].toString()) : <any>undefined;
            this.apiEndpoint = _data["apiEndpoint"];
        }
    }

    static fromJS(data: any): PoolInfo {
        data = typeof data === 'object' ? data : {};
        let result = new PoolInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["coin"] = this.coin ? this.coin.toJSON() : <any>undefined;
        if (this.ports) {
            data["ports"] = {};
            for (let key in this.ports) {
                if (this.ports.hasOwnProperty(key))
                    (<any>data["ports"])[key] = this.ports[key] ? this.ports[key].toJSON() : <any>undefined;
            }
        }
        data["paymentProcessing"] = this.paymentProcessing ? this.paymentProcessing.toJSON() : <any>undefined;
        data["shareBasedBanning"] = this.shareBasedBanning ? this.shareBasedBanning.toJSON() : <any>undefined;
        data["clientConnectionTimeout"] = this.clientConnectionTimeout;
        data["jobRebroadcastTimeout"] = this.jobRebroadcastTimeout;
        data["blockRefreshInterval"] = this.blockRefreshInterval;
        data["poolFeePercent"] = this.poolFeePercent;
        data["address"] = this.address;
        data["addressInfoLink"] = this.addressInfoLink;
        data["poolStats"] = this.poolStats ? this.poolStats.toJSON() : <any>undefined;
        data["networkStats"] = this.networkStats ? this.networkStats.toJSON() : <any>undefined;
        if (Array.isArray(this.topMiners)) {
            data["topMiners"] = [];
            for (let item of this.topMiners)
                data["topMiners"].push(item.toJSON());
        }
        data["totalPaid"] = this.totalPaid;
        data["totalBlocks"] = this.totalBlocks;
        data["lastPoolBlockTime"] = this.lastPoolBlockTime ? this.lastPoolBlockTime.toISOString() : <any>undefined;
        data["apiEndpoint"] = this.apiEndpoint;
        return data;
    }
}

export interface IPoolInfo {
    id: string | undefined;
    coin: ApiCoinConfig | undefined;
    ports: { [key: string]: PoolEndpoint; } | undefined;
    paymentProcessing: ApiPoolPaymentProcessingConfig | undefined;
    shareBasedBanning: PoolShareBasedBanningConfig | undefined;
    clientConnectionTimeout: number;
    jobRebroadcastTimeout: number;
    blockRefreshInterval: number;
    poolFeePercent: number;
    address: string | undefined;
    addressInfoLink: string | undefined;
    poolStats: PoolStats | undefined;
    networkStats: BlockchainStats | undefined;
    topMiners: MinerPerformanceStats[] | undefined;
    totalPaid: number;
    totalBlocks: number;
    lastPoolBlockTime: moment.Moment | undefined;
    apiEndpoint: string | undefined;
}

export class ApiCoinConfig implements IApiCoinConfig {
    type!: string | undefined;
    name!: string | undefined;
    symbol!: string | undefined;
    website!: string | undefined;
    family!: string | undefined;
    algorithm!: string | undefined;
    twitter!: string | undefined;
    discord!: string | undefined;
    telegram!: string | undefined;
    canonicalName!: string | undefined;

    constructor(data?: IApiCoinConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.name = _data["name"];
            this.symbol = _data["symbol"];
            this.website = _data["website"];
            this.family = _data["family"];
            this.algorithm = _data["algorithm"];
            this.twitter = _data["twitter"];
            this.discord = _data["discord"];
            this.telegram = _data["telegram"];
            this.canonicalName = _data["canonicalName"];
        }
    }

    static fromJS(data: any): ApiCoinConfig {
        data = typeof data === 'object' ? data : {};
        let result = new ApiCoinConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["website"] = this.website;
        data["family"] = this.family;
        data["algorithm"] = this.algorithm;
        data["twitter"] = this.twitter;
        data["discord"] = this.discord;
        data["telegram"] = this.telegram;
        data["canonicalName"] = this.canonicalName;
        return data;
    }
}

export interface IApiCoinConfig {
    type: string | undefined;
    name: string | undefined;
    symbol: string | undefined;
    website: string | undefined;
    family: string | undefined;
    algorithm: string | undefined;
    twitter: string | undefined;
    discord: string | undefined;
    telegram: string | undefined;
    canonicalName: string | undefined;
}

export class ApiPoolPaymentProcessingConfig implements IApiPoolPaymentProcessingConfig {
    enabled!: boolean;
    minimumPayment!: number;
    payoutScheme!: string | undefined;
    payoutSchemeConfig!: any | undefined;
    extra!: { [key: string]: any; } | undefined;
    additionalProperties!: { [key: string]: any; } | undefined;

    constructor(data?: IApiPoolPaymentProcessingConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enabled = _data["enabled"];
            this.minimumPayment = _data["minimumPayment"];
            this.payoutScheme = _data["payoutScheme"];
            this.payoutSchemeConfig = _data["payoutSchemeConfig"];
            if (_data["extra"]) {
                this.extra = {} as any;
                for (let key in _data["extra"]) {
                    if (_data["extra"].hasOwnProperty(key))
                        (<any>this.extra)![key] = _data["extra"][key];
                }
            }
            if (_data["additionalProperties"]) {
                this.additionalProperties = {} as any;
                for (let key in _data["additionalProperties"]) {
                    if (_data["additionalProperties"].hasOwnProperty(key))
                        (<any>this.additionalProperties)![key] = _data["additionalProperties"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApiPoolPaymentProcessingConfig {
        data = typeof data === 'object' ? data : {};
        let result = new ApiPoolPaymentProcessingConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enabled"] = this.enabled;
        data["minimumPayment"] = this.minimumPayment;
        data["payoutScheme"] = this.payoutScheme;
        data["payoutSchemeConfig"] = this.payoutSchemeConfig;
        if (this.extra) {
            data["extra"] = {};
            for (let key in this.extra) {
                if (this.extra.hasOwnProperty(key))
                    (<any>data["extra"])[key] = this.extra[key];
            }
        }
        if (this.additionalProperties) {
            data["additionalProperties"] = {};
            for (let key in this.additionalProperties) {
                if (this.additionalProperties.hasOwnProperty(key))
                    (<any>data["additionalProperties"])[key] = this.additionalProperties[key];
            }
        }
        return data;
    }
}

export interface IApiPoolPaymentProcessingConfig {
    enabled: boolean;
    minimumPayment: number;
    payoutScheme: string | undefined;
    payoutSchemeConfig: any | undefined;
    extra: { [key: string]: any; } | undefined;
    additionalProperties: { [key: string]: any; } | undefined;
}

export class MinerPerformanceStats implements IMinerPerformanceStats {
    miner!: string | undefined;
    hashrate!: number;
    sharesPerSecond!: number;

    constructor(data?: IMinerPerformanceStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.miner = _data["miner"];
            this.hashrate = _data["hashrate"];
            this.sharesPerSecond = _data["sharesPerSecond"];
        }
    }

    static fromJS(data: any): MinerPerformanceStats {
        data = typeof data === 'object' ? data : {};
        let result = new MinerPerformanceStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["miner"] = this.miner;
        data["hashrate"] = this.hashrate;
        data["sharesPerSecond"] = this.sharesPerSecond;
        return data;
    }
}

export interface IMinerPerformanceStats {
    miner: string | undefined;
    hashrate: number;
    sharesPerSecond: number;
}

export class MinerDetailsModel implements IMinerDetailsModel {
    pool!: PoolInfo | undefined;
    poolId!: string | undefined;
    poolLink!: string | undefined;
    poolCurrency!: string | undefined;
    poolMinimumPayment!: number | undefined;
    miner!: string | undefined;
    hashrateUnits!: string[] | undefined;
    payments!: PagedResultResponseOfPaymentOf | undefined;
    earnings!: PagedResultResponseOfAmountByDateOf | undefined;
    minerStats!: MinerStats | undefined;
    minerSettings!: MinerSettings | undefined;
    perfMode!: string | undefined;
    balanceChanges!: PagedResultResponseOfBalanceChangeOf | undefined;
    otherPools!: PoolInfo[] | undefined;

    constructor(data?: IMinerDetailsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pool = _data["pool"] ? PoolInfo.fromJS(_data["pool"]) : <any>undefined;
            this.poolId = _data["poolId"];
            this.poolLink = _data["poolLink"];
            this.poolCurrency = _data["poolCurrency"];
            this.poolMinimumPayment = _data["poolMinimumPayment"];
            this.miner = _data["miner"];
            if (Array.isArray(_data["hashrateUnits"])) {
                this.hashrateUnits = [] as any;
                for (let item of _data["hashrateUnits"])
                    this.hashrateUnits!.push(item);
            }
            this.payments = _data["payments"] ? PagedResultResponseOfPaymentOf.fromJS(_data["payments"]) : <any>undefined;
            this.earnings = _data["earnings"] ? PagedResultResponseOfAmountByDateOf.fromJS(_data["earnings"]) : <any>undefined;
            this.minerStats = _data["minerStats"] ? MinerStats.fromJS(_data["minerStats"]) : <any>undefined;
            this.minerSettings = _data["minerSettings"] ? MinerSettings.fromJS(_data["minerSettings"]) : <any>undefined;
            this.perfMode = _data["perfMode"];
            this.balanceChanges = _data["balanceChanges"] ? PagedResultResponseOfBalanceChangeOf.fromJS(_data["balanceChanges"]) : <any>undefined;
            if (Array.isArray(_data["otherPools"])) {
                this.otherPools = [] as any;
                for (let item of _data["otherPools"])
                    this.otherPools!.push(PoolInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MinerDetailsModel {
        data = typeof data === 'object' ? data : {};
        let result = new MinerDetailsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pool"] = this.pool ? this.pool.toJSON() : <any>undefined;
        data["poolId"] = this.poolId;
        data["poolLink"] = this.poolLink;
        data["poolCurrency"] = this.poolCurrency;
        data["poolMinimumPayment"] = this.poolMinimumPayment;
        data["miner"] = this.miner;
        if (Array.isArray(this.hashrateUnits)) {
            data["hashrateUnits"] = [];
            for (let item of this.hashrateUnits)
                data["hashrateUnits"].push(item);
        }
        data["payments"] = this.payments ? this.payments.toJSON() : <any>undefined;
        data["earnings"] = this.earnings ? this.earnings.toJSON() : <any>undefined;
        data["minerStats"] = this.minerStats ? this.minerStats.toJSON() : <any>undefined;
        data["minerSettings"] = this.minerSettings ? this.minerSettings.toJSON() : <any>undefined;
        data["perfMode"] = this.perfMode;
        data["balanceChanges"] = this.balanceChanges ? this.balanceChanges.toJSON() : <any>undefined;
        if (Array.isArray(this.otherPools)) {
            data["otherPools"] = [];
            for (let item of this.otherPools)
                data["otherPools"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMinerDetailsModel {
    pool: PoolInfo | undefined;
    poolId: string | undefined;
    poolLink: string | undefined;
    poolCurrency: string | undefined;
    poolMinimumPayment: number | undefined;
    miner: string | undefined;
    hashrateUnits: string[] | undefined;
    payments: PagedResultResponseOfPaymentOf | undefined;
    earnings: PagedResultResponseOfAmountByDateOf | undefined;
    minerStats: MinerStats | undefined;
    minerSettings: MinerSettings | undefined;
    perfMode: string | undefined;
    balanceChanges: PagedResultResponseOfBalanceChangeOf | undefined;
    otherPools: PoolInfo[] | undefined;
}

export class PoolDetailsModel implements IPoolDetailsModel {
    pool!: PoolInfo | undefined;
    poolId!: string | undefined;
    poolCurrency!: string | undefined;
    poolMinimumPayment!: number | undefined;
    ports!: number[] | undefined;
    stats!: AggregatedPoolStats[] | undefined;
    statsMonthly!: AggregatedPoolStats[] | undefined;
    hashrateUnits!: string[] | undefined;
    hashrateUnit!: string | undefined;
    networkHashrateUnit!: string | undefined;
    blocks!: PagedResultResponseOfBlockOf | undefined;
    blockEffortAverage!: number | undefined;
    payments!: PagedResultResponseOfPaymentOf | undefined;
    minerStats!: MinerStats | undefined;
    minerSettings!: MinerSettings | undefined;
    ticker!: CgTicker | undefined;
    totalPaid!: number;
    minerDashboardUrlBase!: string | undefined;
    announcementMarkdown!: string | undefined;
    bountyMarkdown!: string | undefined;
    otherPools!: PoolInfo[] | undefined;

    constructor(data?: IPoolDetailsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pool = _data["pool"] ? PoolInfo.fromJS(_data["pool"]) : <any>undefined;
            this.poolId = _data["poolId"];
            this.poolCurrency = _data["poolCurrency"];
            this.poolMinimumPayment = _data["poolMinimumPayment"];
            if (Array.isArray(_data["ports"])) {
                this.ports = [] as any;
                for (let item of _data["ports"])
                    this.ports!.push(item);
            }
            if (Array.isArray(_data["stats"])) {
                this.stats = [] as any;
                for (let item of _data["stats"])
                    this.stats!.push(AggregatedPoolStats.fromJS(item));
            }
            if (Array.isArray(_data["statsMonthly"])) {
                this.statsMonthly = [] as any;
                for (let item of _data["statsMonthly"])
                    this.statsMonthly!.push(AggregatedPoolStats.fromJS(item));
            }
            if (Array.isArray(_data["hashrateUnits"])) {
                this.hashrateUnits = [] as any;
                for (let item of _data["hashrateUnits"])
                    this.hashrateUnits!.push(item);
            }
            this.hashrateUnit = _data["hashrateUnit"];
            this.networkHashrateUnit = _data["networkHashrateUnit"];
            this.blocks = _data["blocks"] ? PagedResultResponseOfBlockOf.fromJS(_data["blocks"]) : <any>undefined;
            this.blockEffortAverage = _data["blockEffortAverage"];
            this.payments = _data["payments"] ? PagedResultResponseOfPaymentOf.fromJS(_data["payments"]) : <any>undefined;
            this.minerStats = _data["minerStats"] ? MinerStats.fromJS(_data["minerStats"]) : <any>undefined;
            this.minerSettings = _data["minerSettings"] ? MinerSettings.fromJS(_data["minerSettings"]) : <any>undefined;
            this.ticker = _data["ticker"] ? CgTicker.fromJS(_data["ticker"]) : <any>undefined;
            this.totalPaid = _data["totalPaid"];
            this.minerDashboardUrlBase = _data["minerDashboardUrlBase"];
            this.announcementMarkdown = _data["announcementMarkdown"];
            this.bountyMarkdown = _data["bountyMarkdown"];
            if (Array.isArray(_data["otherPools"])) {
                this.otherPools = [] as any;
                for (let item of _data["otherPools"])
                    this.otherPools!.push(PoolInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PoolDetailsModel {
        data = typeof data === 'object' ? data : {};
        let result = new PoolDetailsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pool"] = this.pool ? this.pool.toJSON() : <any>undefined;
        data["poolId"] = this.poolId;
        data["poolCurrency"] = this.poolCurrency;
        data["poolMinimumPayment"] = this.poolMinimumPayment;
        if (Array.isArray(this.ports)) {
            data["ports"] = [];
            for (let item of this.ports)
                data["ports"].push(item);
        }
        if (Array.isArray(this.stats)) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        if (Array.isArray(this.statsMonthly)) {
            data["statsMonthly"] = [];
            for (let item of this.statsMonthly)
                data["statsMonthly"].push(item.toJSON());
        }
        if (Array.isArray(this.hashrateUnits)) {
            data["hashrateUnits"] = [];
            for (let item of this.hashrateUnits)
                data["hashrateUnits"].push(item);
        }
        data["hashrateUnit"] = this.hashrateUnit;
        data["networkHashrateUnit"] = this.networkHashrateUnit;
        data["blocks"] = this.blocks ? this.blocks.toJSON() : <any>undefined;
        data["blockEffortAverage"] = this.blockEffortAverage;
        data["payments"] = this.payments ? this.payments.toJSON() : <any>undefined;
        data["minerStats"] = this.minerStats ? this.minerStats.toJSON() : <any>undefined;
        data["minerSettings"] = this.minerSettings ? this.minerSettings.toJSON() : <any>undefined;
        data["ticker"] = this.ticker ? this.ticker.toJSON() : <any>undefined;
        data["totalPaid"] = this.totalPaid;
        data["minerDashboardUrlBase"] = this.minerDashboardUrlBase;
        data["announcementMarkdown"] = this.announcementMarkdown;
        data["bountyMarkdown"] = this.bountyMarkdown;
        if (Array.isArray(this.otherPools)) {
            data["otherPools"] = [];
            for (let item of this.otherPools)
                data["otherPools"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPoolDetailsModel {
    pool: PoolInfo | undefined;
    poolId: string | undefined;
    poolCurrency: string | undefined;
    poolMinimumPayment: number | undefined;
    ports: number[] | undefined;
    stats: AggregatedPoolStats[] | undefined;
    statsMonthly: AggregatedPoolStats[] | undefined;
    hashrateUnits: string[] | undefined;
    hashrateUnit: string | undefined;
    networkHashrateUnit: string | undefined;
    blocks: PagedResultResponseOfBlockOf | undefined;
    blockEffortAverage: number | undefined;
    payments: PagedResultResponseOfPaymentOf | undefined;
    minerStats: MinerStats | undefined;
    minerSettings: MinerSettings | undefined;
    ticker: CgTicker | undefined;
    totalPaid: number;
    minerDashboardUrlBase: string | undefined;
    announcementMarkdown: string | undefined;
    bountyMarkdown: string | undefined;
    otherPools: PoolInfo[] | undefined;
}

export class AggregatedPoolStats implements IAggregatedPoolStats {
    poolHashrate!: number;
    connectedMiners!: number;
    validSharesPerSecond!: number;
    networkHashrate!: number;
    networkDifficulty!: number;
    created!: moment.Moment;

    constructor(data?: IAggregatedPoolStats) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.poolHashrate = _data["poolHashrate"];
            this.connectedMiners = _data["connectedMiners"];
            this.validSharesPerSecond = _data["validSharesPerSecond"];
            this.networkHashrate = _data["networkHashrate"];
            this.networkDifficulty = _data["networkDifficulty"];
            this.created = _data["created"] ? moment(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AggregatedPoolStats {
        data = typeof data === 'object' ? data : {};
        let result = new AggregatedPoolStats();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["poolHashrate"] = this.poolHashrate;
        data["connectedMiners"] = this.connectedMiners;
        data["validSharesPerSecond"] = this.validSharesPerSecond;
        data["networkHashrate"] = this.networkHashrate;
        data["networkDifficulty"] = this.networkDifficulty;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAggregatedPoolStats {
    poolHashrate: number;
    connectedMiners: number;
    validSharesPerSecond: number;
    networkHashrate: number;
    networkDifficulty: number;
    created: moment.Moment;
}

export class CgTickerInfo implements ICgTickerInfo {
    id!: number;

    constructor(data?: ICgTickerInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CgTickerInfo {
        data = typeof data === 'object' ? data : {};
        let result = new CgTickerInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface ICgTickerInfo {
    id: number;
}

export class CgTicker extends CgTickerInfo implements ICgTicker {
    quotes!: { [key: string]: CgQuote; } | undefined;

    constructor(data?: ICgTicker) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (_data["quotes"]) {
                this.quotes = {} as any;
                for (let key in _data["quotes"]) {
                    if (_data["quotes"].hasOwnProperty(key))
                        (<any>this.quotes)![key] = _data["quotes"][key] ? CgQuote.fromJS(_data["quotes"][key]) : new CgQuote();
                }
            }
        }
    }

    static fromJS(data: any): CgTicker {
        data = typeof data === 'object' ? data : {};
        let result = new CgTicker();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.quotes) {
            data["quotes"] = {};
            for (let key in this.quotes) {
                if (this.quotes.hasOwnProperty(key))
                    (<any>data["quotes"])[key] = this.quotes[key] ? this.quotes[key].toJSON() : <any>undefined;
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface ICgTicker extends ICgTickerInfo {
    quotes: { [key: string]: CgQuote; } | undefined;
}

export class CgQuote implements ICgQuote {
    price!: number;
    volume24h!: number;
    marketCap!: number;
    percentChange24h!: number;

    constructor(data?: ICgQuote) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.price = _data["price"];
            this.volume24h = _data["volume24h"];
            this.marketCap = _data["marketCap"];
            this.percentChange24h = _data["percentChange24h"];
        }
    }

    static fromJS(data: any): CgQuote {
        data = typeof data === 'object' ? data : {};
        let result = new CgQuote();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["price"] = this.price;
        data["volume24h"] = this.volume24h;
        data["marketCap"] = this.marketCap;
        data["percentChange24h"] = this.percentChange24h;
        return data;
    }
}

export interface ICgQuote {
    price: number;
    volume24h: number;
    marketCap: number;
    percentChange24h: number;
}

export class MinerDownloadConfig implements IMinerDownloadConfig {
    xmrigLinux!: string | undefined;
    xmrigWindows!: string | undefined;
    tRexWindows!: string | undefined;
    tRexLinux!: string | undefined;
    wildrigWindows!: string | undefined;
    wildrigLinux!: string | undefined;
    ewbfWindows!: string | undefined;
    ewbfLinux!: string | undefined;
    lolMinerWindows!: string | undefined;
    lolMinerLinux!: string | undefined;
    srbMinerWindows!: string | undefined;
    srbMinerLinux!: string | undefined;
    cryptoDredgeWindows!: string | undefined;
    cryptoDredgeLinux!: string | undefined;
    ethminerWindows!: string | undefined;
    ethminerLinux!: string | undefined;
    gMinerWindows!: string | undefined;
    gMinerLinux!: string | undefined;
    ccMinerWindows!: string | undefined;
    ccMinerLinux!: string | undefined;

    constructor(data?: IMinerDownloadConfig) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.xmrigLinux = _data["xmrigLinux"];
            this.xmrigWindows = _data["xmrigWindows"];
            this.tRexWindows = _data["tRexWindows"];
            this.tRexLinux = _data["tRexLinux"];
            this.wildrigWindows = _data["wildrigWindows"];
            this.wildrigLinux = _data["wildrigLinux"];
            this.ewbfWindows = _data["ewbfWindows"];
            this.ewbfLinux = _data["ewbfLinux"];
            this.lolMinerWindows = _data["lolMinerWindows"];
            this.lolMinerLinux = _data["lolMinerLinux"];
            this.srbMinerWindows = _data["srbMinerWindows"];
            this.srbMinerLinux = _data["srbMinerLinux"];
            this.cryptoDredgeWindows = _data["cryptoDredgeWindows"];
            this.cryptoDredgeLinux = _data["cryptoDredgeLinux"];
            this.ethminerWindows = _data["ethminerWindows"];
            this.ethminerLinux = _data["ethminerLinux"];
            this.gMinerWindows = _data["gMinerWindows"];
            this.gMinerLinux = _data["gMinerLinux"];
            this.ccMinerWindows = _data["ccMinerWindows"];
            this.ccMinerLinux = _data["ccMinerLinux"];
        }
    }

    static fromJS(data: any): MinerDownloadConfig {
        data = typeof data === 'object' ? data : {};
        let result = new MinerDownloadConfig();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xmrigLinux"] = this.xmrigLinux;
        data["xmrigWindows"] = this.xmrigWindows;
        data["tRexWindows"] = this.tRexWindows;
        data["tRexLinux"] = this.tRexLinux;
        data["wildrigWindows"] = this.wildrigWindows;
        data["wildrigLinux"] = this.wildrigLinux;
        data["ewbfWindows"] = this.ewbfWindows;
        data["ewbfLinux"] = this.ewbfLinux;
        data["lolMinerWindows"] = this.lolMinerWindows;
        data["lolMinerLinux"] = this.lolMinerLinux;
        data["srbMinerWindows"] = this.srbMinerWindows;
        data["srbMinerLinux"] = this.srbMinerLinux;
        data["cryptoDredgeWindows"] = this.cryptoDredgeWindows;
        data["cryptoDredgeLinux"] = this.cryptoDredgeLinux;
        data["ethminerWindows"] = this.ethminerWindows;
        data["ethminerLinux"] = this.ethminerLinux;
        data["gMinerWindows"] = this.gMinerWindows;
        data["gMinerLinux"] = this.gMinerLinux;
        data["ccMinerWindows"] = this.ccMinerWindows;
        data["ccMinerLinux"] = this.ccMinerLinux;
        return data;
    }
}

export interface IMinerDownloadConfig {
    xmrigLinux: string | undefined;
    xmrigWindows: string | undefined;
    tRexWindows: string | undefined;
    tRexLinux: string | undefined;
    wildrigWindows: string | undefined;
    wildrigLinux: string | undefined;
    ewbfWindows: string | undefined;
    ewbfLinux: string | undefined;
    lolMinerWindows: string | undefined;
    lolMinerLinux: string | undefined;
    srbMinerWindows: string | undefined;
    srbMinerLinux: string | undefined;
    cryptoDredgeWindows: string | undefined;
    cryptoDredgeLinux: string | undefined;
    ethminerWindows: string | undefined;
    ethminerLinux: string | undefined;
    gMinerWindows: string | undefined;
    gMinerLinux: string | undefined;
    ccMinerWindows: string | undefined;
    ccMinerLinux: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
    return obj && obj.isAxiosError === true;
}